// Generated by CodiumAI

const User = require("../models/userModel");
const Chat = require("../models/chatModel");
const {
  checkUsername,
  getChatRequests,
  createChat,
  getChat,
  manageChatRequest,
  chatsOverview,
  sendMessage,
} = require("../controller/message/chatController");

describe("checkUsername", () => {
  // Returns a 200 status code and user information if the username exists and has no profile picture
  it("should return a 200 status code and user information when the username exists and has no profile picture", async () => {
    const req = { params: { username: "existingUser" } };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const user = { username: "existingUser", profilePicture: null };
    User.findOne = jest.fn().mockResolvedValue(user);

    await checkUsername(req, res);

    expect(User.findOne).toHaveBeenCalledWith({ username: "existingUser" });
    expect(res.status).toHaveBeenCalledWith(200);
    expect(res.json).toHaveBeenCalledWith({
      success: true,
      username: "existingUser",
    });
  });

  // Returns a 400 status code and error message if the username does not exist
  it("should return a 400 status code and error message when the username does not exist", async () => {
    const req = { params: { username: "nonExistingUser" } };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    User.findOne = jest.fn().mockResolvedValue(null);

    await checkUsername(req, res);

    expect(User.findOne).toHaveBeenCalledWith({ username: "nonExistingUser" });
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.json).toHaveBeenCalledWith({
      success: false,
      message: "No user found with that username",
    });
  });
});

// Generated by CodiumAI

describe("getChatRequests", () => {
  // Function successfully retrieves chat requests for the user
  it("should successfully retrieve chat requests for the user", async () => {
    const req = {
      user: {
        userId: "validUserId",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const user = {
      pendingChatRequests: [
        {
          chat: {
            messages: [
              {
                message: "Test message",
                sender: {
                  username: "TestUser",
                },
              },
            ],
            isPendingRequest: true,
          },
        },
      ],
    };
    User.findById = jest.fn().mockReturnValue({
      populate: jest.fn().mockResolvedValue(user),
    });

    await getChatRequests(req, res);

    expect(User.findById).toHaveBeenCalledWith("validUserId");
    expect(res.status).toHaveBeenCalledWith(200);
    expect(res.json).toHaveBeenCalledWith({
      success: true,
      chatRequests: user.pendingChatRequests,
    });
  });

  // User ID in request object is invalid, function returns error message
  //   it("should return error message when user ID is invalid", async () => {
  //     const req = {
  //       user: {
  //         userId: "invalidUserId",
  //       },
  //     };
  //     const res = {
  //       status: jest.fn().mockReturnThis(),
  //       json: jest.fn(),
  //     };
  //     User.findById = jest.fn().mockRejectedValue(new Error("Invalid user ID"));

  //     await getChatRequests(req, res);

  //     expect(User.findById).toHaveBeenCalledWith("invalidUserId");
  //     expect(res.status).toHaveBeenCalledWith(500);
  //     expect(res.json).toHaveBeenCalledWith({
  //       success: false,
  //       message: "Invalid user ID",
  //     });
  //   });

  // User has no pending chat requests, function returns empty array
  it("should return an empty array when user has no pending chat requests", async () => {
    const req = {
      user: {
        userId: "validUserId",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const user = {
      pendingChatRequests: [],
    };
    User.findById = jest.fn().mockReturnValue({
      populate: jest.fn().mockResolvedValue(user),
    });

    await getChatRequests(req, res);

    expect(User.findById).toHaveBeenCalledWith("validUserId");
    expect(res.status).toHaveBeenCalledWith(200);
    expect(res.json).toHaveBeenCalledWith({
      success: true,
      chatRequests: user.pendingChatRequests,
    });
  });

  // Chat requests have no messages, function returns empty array
  it("should return an empty array when chat requests have no messages", async () => {
    const req = {
      user: {
        userId: "validUserId",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const user = {
      pendingChatRequests: [
        {
          chat: {
            messages: [],
            isPendingRequest: true,
          },
        },
      ],
    };
    User.findById = jest.fn().mockReturnValue({
      populate: jest.fn().mockResolvedValue(user),
    });

    await getChatRequests(req, res);

    expect(User.findById).toHaveBeenCalledWith("validUserId");
    expect(res.status).toHaveBeenCalledWith(200);
    expect(res.json).toHaveBeenCalledWith({
      success: true,
      chatRequests: user.pendingChatRequests,
    });
  });

  // Chat requests have messages, function returns messages
  it("should return messages when chat requests have messages", async () => {
    const req = {
      user: {
        userId: "validUserId",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const user = {
      pendingChatRequests: [
        {
          chat: {
            messages: [
              {
                message: "Test message",
                sender: {
                  username: "TestUser",
                },
              },
            ],
            isPendingRequest: true,
          },
        },
      ],
    };
    User.findById = jest.fn().mockReturnValue({
      populate: jest.fn().mockResolvedValue(user),
    });

    await getChatRequests(req, res);

    expect(User.findById).toHaveBeenCalledWith("validUserId");
    expect(res.status).toHaveBeenCalledWith(200);
    expect(res.json).toHaveBeenCalledWith({
      success: true,
      chatRequests: user.pendingChatRequests,
    });
  });
});

// Generated by CodiumAI

describe("createChat", () => {
  // Create a chat between two users with valid recipient and message, and return a success response

  // Return a 400 error response if recipient is not found
  it("should return a 400 error response if recipient is not found", async () => {
    const req = {
      body: {
        recipient: "invalidRecipient",
        message: "validMessage",
      },
      file: null,
      user: {
        userId: "validUserId",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const User = require("../models/userModel");
    const Chat = require("../models/chatModel");
    const { getRecieverSocket } = require("../utils/socket");
    const { sendFileToS3 } = require("../utils/s3-bucket");

    User.findOne = jest.fn().mockResolvedValue(null);

    await createChat(req, res);

    expect(User.findOne).toHaveBeenCalledWith({ username: "invalidRecipient" });
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.json).toHaveBeenCalledWith({
      success: false,
      message: "No user found with that username",
    });
  });

  // Create a chat between two users with valid recipient and media file, and return a success response

  // Return a 400 error response if chat already exists between the two users
  it("should return a 400 error response if chat already exists between the two users", async () => {
    const req = {
      body: {
        recipient: "validRecipient",
        message: "validMessage",
      },
      file: null,
      user: {
        userId: "validUserId",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const User = require("../models/userModel");
    const Chat = require("../models/chatModel");

    User.findOne = jest.fn().mockResolvedValue({ _id: "validRecipientId" });
    Chat.findOne = jest.fn().mockResolvedValue({});

    await createChat(req, res);

    expect(User.findOne).toHaveBeenCalledWith({ username: "validRecipient" });
    expect(Chat.findOne).toHaveBeenCalledWith({
      participants: ["validUserId", "validRecipientId"],
    });
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.json).toHaveBeenCalledWith({
      success: false,
      message: "Chat already exists",
    });
  });

  // Return a 500 error response if there is an error while creating the chat
  it("should return a 500 error response if there is an error while creating the chat", async () => {
    const req = {
      body: {
        recipient: "validRecipient",
        message: "validMessage",
      },
      file: null,
      user: {
        userId: "validUserId",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const User = require("../models/userModel");
    const Chat = require("../models/chatModel");

    User.findOne = jest
      .fn()
      .mockRejectedValue(new Error("Error while creating chat"));

    await createChat(req, res);

    expect(User.findOne).toHaveBeenCalledWith({ username: "validRecipient" });
    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.json).toHaveBeenCalledWith({
      success: false,
      message: "Error while creating chat",
    });
  });
});

// Generated by CodiumAI

describe("getChat", () => {
  // Returns a 500 status code with an error message when an error occurs
  it("should return a 500 status code with an error message when an error occurs", async () => {
    const req = {
      params: {
        chatId: "validChatId",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const expectedErrorMessage =
      "input must be a 24 character hex string, 12 byte Uint8Array, or an integer";
    Chat.aggregate = jest
      .fn()
      .mockRejectedValue(new Error(expectedErrorMessage));

    await getChat(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.json).toHaveBeenCalledWith({
      success: false,
      message: expectedErrorMessage,
    });
  });

  // Returns a 500 status code with an error message when an error occurs during execution
  it("should return a 500 status code with an error message when an error occurs during execution", async () => {
    const req = {
      params: {
        chatId: "validChatId",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const errorMessage =
      "input must be a 24 character hex string, 12 byte Uint8Array, or an integer";
    Chat.aggregate = jest.fn().mockRejectedValue(new Error(errorMessage));

    await getChat(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.json).toHaveBeenCalledWith({
      success: false,
      message: errorMessage,
    });
  });
});

// Generated by CodiumAI

describe("manageChatRequest", () => {
  // Successfully decline chat request
  it("should successfully decline chat request when chat is pending", async () => {
    const req = {
      user: {
        userId: "user1",
      },
      body: {
        chatId: "chat1",
        accept: false,
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const User = require("../models/userModel");
    const Chat = require("../models/chatModel");
    User.findById = jest
      .fn()
      .mockResolvedValue({ _id: "user1", pendingChatRequests: [] });
    Chat.findById = jest.fn().mockResolvedValue({
      _id: "chat1",
      participants: ["user1", "user2"],
      isPendingRequest: true,
      save: jest.fn(),
    });
    User.findById.mockImplementationOnce(() => {
      return {
        pendingChatRequests: [{ chat: "chat1" }],
        save: jest.fn(),
      };
    });
    User.findById.mockImplementationOnce(() => {
      return {
        pendingChatRequests: [{ chat: "chat1" }],
        save: jest.fn(),
      };
    });
    User.findById.mockImplementationOnce(() => {
      return {
        pendingChatRequests: [{ chat: "chat1" }],
        save: jest.fn(),
      };
    });
    await manageChatRequest(req, res);
    expect(User.findById).toHaveBeenCalledWith("user1");
    expect(Chat.findById).toHaveBeenCalledWith("chat1");
    expect(res.status).toHaveBeenCalledWith(200);
    expect(res.json).toHaveBeenCalledWith({
      success: true,
      message: "Chat request declined",
    });
  });

  // Chat not found error
  it("should return chat not found error when chat does not exist", async () => {
    const req = {
      user: {
        userId: "user1",
      },
      body: {
        chatId: "chat1",
        accept: true,
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const User = require("../models/userModel");
    const Chat = require("../models/chatModel");
    User.findById = jest
      .fn()
      .mockResolvedValue({ _id: "user1", pendingChatRequests: [] });
    Chat.findById = jest.fn().mockResolvedValue(null);
    await manageChatRequest(req, res);
    expect(User.findById).toHaveBeenCalledWith("user1");
    expect(Chat.findById).toHaveBeenCalledWith("chat1");
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.json).toHaveBeenCalledWith({
      success: false,
      message: "Chat not found",
    });
  });

  // Chat request is not pending error
  it("should return chat request is not pending error when chat request is not pending", async () => {
    const req = {
      user: {
        userId: "user1",
      },
      body: {
        chatId: "chat1",
        accept: true,
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const User = require("../models/userModel");
    const Chat = require("../models/chatModel");
    User.findById = jest
      .fn()
      .mockResolvedValue({ _id: "user1", pendingChatRequests: [] });
    Chat.findById = jest.fn().mockResolvedValue({
      _id: "chat1",
      participants: ["user1", "user2"],
      isPendingRequest: false,
    });
    await manageChatRequest(req, res);
    expect(User.findById).toHaveBeenCalledWith("user1");
    expect(Chat.findById).toHaveBeenCalledWith("chat1");
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.json).toHaveBeenCalledWith({
      success: false,
      message: "This chat request is not pending",
    });
  });
});

// Generated by CodiumAI

describe("chatsOverview", () => {
  // Should return an error response when user id is not valid
  it("should return an error response when user id is not valid", async () => {
    const req = {
      params: {
        filter: "all",
      },
      user: {
        userId: "invalidUserId",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    await chatsOverview(req, res);
    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.json).toHaveBeenCalledWith({
      success: false,
      message: expect.any(String),
    });
  });
});

// Generated by CodiumAI

describe("sendMessage", () => {
  // Successfully send a message with text only
  it("should successfully send a message with text only", async () => {
    const req = {
      params: {
        chatId: "chatId123",
      },
      user: {
        userId: "userId123",
      },
      body: {
        message: "Hello, how are you?",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const chat = {
      _id: "chatId123",
      messages: [],
      save: jest.fn(),
      participants: ["userId123", "anotherUserId"],
    };
    Chat.findById = jest.fn().mockResolvedValue(chat);

    await sendMessage(req, res);

    expect(Chat.findById).toHaveBeenCalledWith("chatId123");
    expect(res.status).toHaveBeenCalledWith(201);
    expect(res.json).toHaveBeenCalledWith({
      success: true,
      message: "Message sent successfully",
    });
    expect(chat.messages).toEqual([
      {
        sender: "userId123",
        message: "Hello, how are you?",
        media: undefined,
        status: "sent",
      },
    ]);
    expect(chat.save).toHaveBeenCalled();
  });

  // Fail to send a message to a non-existent chat
  it("should fail to send a message to a non-existent chat", async () => {
    const req = {
      params: {
        chatId: "nonExistentChatId",
      },
      user: {
        userId: "userId123",
      },
      body: {
        message: "Hello, how are you?",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    Chat.findById = jest.fn().mockResolvedValue(null);

    await sendMessage(req, res);

    expect(Chat.findById).toHaveBeenCalledWith("nonExistentChatId");
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.json).toHaveBeenCalledWith({
      success: false,
      message: "Chat not found",
    });
  });
});
