const { signUp } = require("../controller/Auth/userController");
const User = require("../models/userModel");
const { userExist } = require("../controller/Auth/userController");
const { appLogin } = require("../controller/Auth/appUserController");
const {
  forgotPassword,
  forgotUsername,
} = require("../controller/Auth/userController");

const {
  validatePassword,
  authenticate,
  validateEmail,
} = require("../middlewares/auth");

const {
  hashPassword,
  comparePassword,
  generatePassword,
} = require("../utils/passwords");

// test userExists function
describe("userExist function", () => {
  it("Should return 200 if username is available", async () => {
    const req = {
      params: {
        username: "unique_username1",
      },
    };
    const res = {
      status: jest.fn(() => res),
      json: jest.fn(),
    };
    const userFindOneMock = jest.spyOn(User, "findOne");
    userFindOneMock.mockResolvedValue(null);
    await userExist(req, res);
    expect(res.status).toHaveBeenCalledWith(200);
  });

  it("Should return 409 if user already exists", async () => {
    const req = {
      params: {
        username: "test_user",
      },
    };
    const res = {
      status: jest.fn(() => res),
      json: jest.fn(),
    };
    const userFindOneMock = jest.spyOn(User, "findOne");
    userFindOneMock.mockResolvedValue("test_user");
    await userExist(req, res);
    expect(res.status).toHaveBeenCalledWith(409);
  });
});

// test signUp function
describe("signUp function", () => {
  it("Should return 409 if user already exists", async () => {
    const req = {
      body: {
        username: "test_user",
        email: "email@gmail.com",
        password: "password",
      },
    };
    const res = {
      status: jest.fn(() => res),
      json: jest.fn(),
    };
    const userFindOneMock = jest.spyOn(User, "findOne");
    userFindOneMock.mockResolvedValue("test_user");
    await signUp(req, res);
    expect(res.status).toHaveBeenCalledWith(409);
  });
});

describe("appLogin function", () => {
  it("Should return 404 if invalid credintials", async () => {
    const req = {
      body: {
        usernameOrEmail: "notfound@mail.com",
        password: "password",
      },
    };
    const res = {
      status: jest.fn(() => res),
      json: jest.fn(),
    };
    const userFindOneMock = jest.spyOn(User, "findOne");
    userFindOneMock.mockResolvedValue(null);
    await appLogin(req, res);
    expect(res.status).toHaveBeenCalledWith(404);
  });
});

describe("forgotPassword function", () => {
  it("Should return 404 if user not found", async () => {
    const req = {
      body: {
        username: "notfound",
      },
    };
    const res = {
      status: jest.fn(() => res),
      json: jest.fn(),
    };
    const userFindOneMock = jest.spyOn(User, "findOne");
    userFindOneMock.mockResolvedValue(null);
    await forgotPassword(req, res);
    expect(res.status).toHaveBeenCalledWith(404);
  });
});

describe("forgotUsername function", () => {
  it("Should return 200 and send email if user found", async () => {
    const req = {
      body: {
        email: "test@mail.com",
      },
    };
    const res = {
      status: jest.fn(() => res),
      json: jest.fn(),
    };
    const userFindOneMock = jest.spyOn(User, "findOne");
    userFindOneMock.mockResolvedValue("test_user");
    await forgotUsername(req, res);
    expect(res.status).toHaveBeenCalledWith(200);
  });
});

describe("authenticate", () => {
  // Return 401 Unauthorized when JWT token is missing
  it("should return 401 Unauthorized when JWT token is missing", async () => {
    const req = {
      headers: {},
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const next = jest.fn();

    await authenticate(req, res, next);

    expect(res.status).toHaveBeenCalledWith(401);
    expect(res.json).toHaveBeenCalledWith({ message: "Unauthorized" });
  });
});

describe("validatePassword", () => {
  // Password with at least one letter, one digit, and 8 characters returns True.
  it("should return true when password meets the requirements", () => {
    const password = "Password1";
    const result = validatePassword(password);
    expect(result).toBe(true);
  });

  // Password with less than 8 characters returns False.
  it("should return false when password has less than 8 characters", () => {
    const password = "Pass1";
    const result = validatePassword(password);
    expect(result).toBe(false);
  });
});

// Generated by CodiumAI

describe("validateEmail", () => {
  // Should return true for a valid email address.
  it("should return true when given a valid email address", () => {
    const email = "test@example.com";
    const result = validateEmail(email);
    expect(result).toBe(true);
  });

  // Should return false for an email address with missing local part.
  it("should return false when given an email address with missing local part", () => {
    const email = "@example.com";
    const result = validateEmail(email);
    expect(result).toBe(false);
  });
});

// Generated by CodiumAI

describe("hashPassword", () => {
  // Returns a hashed password when a valid password is provided.
  it("should return a hashed password when a valid password is provided", async () => {
    const password = "validPassword";
    const hashedPassword = await hashPassword(password);
    expect(hashedPassword).toBeDefined();
    expect(typeof hashedPassword).toBe("string");
  });

  // Throws an error when no password is provided.
  it("should throw an error when no password is provided", async () => {
    const password = "";
    await expect(hashPassword(password)).rejects.toThrow(
      "Password is required"
    );
  });
});

// Generated by CodiumAI

describe("comparePassword", () => {
  // The function correctly compares a valid password with its corresponding hashed password.
  it("should return true when comparing a valid password with its corresponding hashed password", async () => {
    const password = "password123";
    const hashedPassword = await bcrypt.hash(password, 10);
    const result = await comparePassword(password, hashedPassword);
    expect(result).toBe(true);
  });

  // The function throws an error if the password is not provided.
  it("should throw an error when the password is not provided", async () => {
    const password = "";
    const hashedPassword = await bcrypt.hash("password123", 10);
    await expect(comparePassword(password, hashedPassword)).rejects.toThrow(
      "Password and hashed password are required"
    );
  });
});

// Generated by CodiumAI

describe("generatePassword", () => {
  // Generates a password of length 10.
  it("should generate a password of length 10", () => {
    const password = generatePassword();
    expect(password.length).toBe(10);
  });

  // Generates a password of length 10.
  it("should generate a password of length 10", () => {
    const password = generatePassword();
    expect(password.length).toBe(10);
  });
});
