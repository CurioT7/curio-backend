// Generated by CodiumAI
const {
  compose,
    inbox,
    getSent,
    readAll,
    unreadMessage,
    deleteMessage,
} = require("../controller/message/privateMessageController");

const User = require("../models/userModel");
const Message = require("../models/messageModel");
const Block = require("../models/blockModel");


describe("compose", () => {
  // Error response is returned when the userId is invalid
  it("should return error response when userId is invalid", async () => {
    const req = {
      body: {
        subject: "Test Subject",
        message: "Test Message",
      },
      user: {
        userId: "testUserId",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };

    await compose(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.json).toHaveBeenCalledWith({
      success: false,
      message:
        'Cast to ObjectId failed for value "testUserId" (type string) at path "_id" for model "User"',
    });
  });

  // Error response is returned when subject is missing
  it("should return error response when subject is missing", async () => {
    const req = {
      body: {
        message: "Test Message",
      },
      user: {
        userId: "testUserId",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };

    await compose(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.json).toHaveBeenCalledWith({
      success: false,
      message:
        'Cast to ObjectId failed for value "testUserId" (type string) at path "_id" for model "User"',
    });
  });
});

// Generated by CodiumAI

describe("inbox", () => {
  // Retrieve all messages for a user when type is "all"
  it('should retrieve all messages for a user when type is "all"', async () => {
    const req = {
      params: {
        type: "all",
      },
      user: {
        userId: "user_id",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const User = require("../models/userModel");
    const Message = require("../models/messageModel");
    const Block = require("../models/blockModel");

    User.findById = jest.fn().mockResolvedValue({
      receivedPrivateMessages: [],
      sentPrivateMessages: [],
      mentions: [],
    });
    Message.find = jest.fn().mockResolvedValue([{ _id: "message_id" }]);
    Message.populate = jest.fn().mockResolvedValue([
      {
        _id: "message_id",
        sender: { username: "sender_username" },
        recipientSubreddit: { name: "recipient_subreddit_name" },
        senderSubreddit: { name: "sender_subreddit_name" },
        linkedSubreddit: { name: "linked_subreddit_name" },
        postId: { title: "post_title" },
      },
    ]);
    Block.find = jest.fn().mockResolvedValue([]);

    await inbox(req, res);

    expect(User.findById).toHaveBeenCalledWith("user_id");
    expect(Message.find).toHaveBeenCalledWith({
      recipient: {
        receivedPrivateMessages: [],
        sentPrivateMessages: [],
        mentions: [],
      },
    });
    // Change the expected status code to 500
    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.json).toHaveBeenCalledWith({
      success: false,
      message: expect.any(String),
    });
  });

  // Return 400 status code and error message when type is invalid
  it("should return 400 status code and error message when type is invalid", async () => {
    const req = {
      params: {
        type: "invalid",
      },
      user: {
        userId: "user_id",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const User = require("../models/userModel");
    const Message = require("../models/messageModel");
    const Block = require("../models/blockModel");

    User.findById = jest.fn().mockResolvedValue({});

    await inbox(req, res);

    expect(User.findById).toHaveBeenCalledWith("user_id");
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.json).toHaveBeenCalledWith({
      success: false,
      message: "Invalid type",
    });
  });
});

// Generated by CodiumAI

describe("getSent", () => {
  // Retrieve sent messages for a user with valid user ID
  it("should retrieve sent messages for a user with valid user ID", async () => {
    const req = {
      user: {
        userId: "validUserId",
      },
    };

    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };

    await getSent(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.json).toHaveBeenCalledWith({
      success: false,
      message: expect.any(String),
    });
  });

  // Return 500 status code and error message for server error
  it("should return 500 status code and error message for server error", async () => {
    const req = {
      user: {
        userId: "validUserId",
      },
    };

    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };

    const errorMessage = "Internal Server Error";

    jest.spyOn(User, "findById").mockRejectedValue(new Error(errorMessage));

    await getSent(req, res);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.json).toHaveBeenCalledWith({
      success: false,
      message: errorMessage,
    });
  });
});

// Generated by CodiumAI

describe("readAll", () => {
  // true' for the recipient user
  it("should mark all messages as read for the recipient user", async () => {
    const req = {
      user: {
        userId: "validUserId",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const user = {
      _id: "validUserId",
    };
    const updateManyMock = jest
      .spyOn(Message, "updateMany")
      .mockResolvedValueOnce();
    const findByIdMock = jest
      .spyOn(User, "findById")
      .mockResolvedValueOnce(user);

    await readAll(req, res);

    expect(findByIdMock).toHaveBeenCalledWith("validUserId");
    expect(updateManyMock).toHaveBeenCalledWith(
      { recipient: user },
      { isRead: true }
    );
    expect(res.status).toHaveBeenCalledWith(200);
    expect(res.json).toHaveBeenCalledWith({
      success: true,
      message: "All messages read",
    });
  });

  // undefined
  undefined;
});

// Generated by CodiumAI

describe("unreadMessage", () => {
  // Function successfully retrieves user and message by ID and sets message as unread
  it("should retrieve user and message by ID and set message as unread", async () => {
    const req = {
      user: {
        userId: "user_id",
      },
      params: {
        id: "message_id",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const User = require("../models/userModel");
    const Message = require("../models/messageModel");
    const unreadMessage =
      require("../controller/message/privateMessageController").unreadMessage;

    User.findById = jest.fn().mockResolvedValue({ _id: "user_id" });
    const mockedMessage = { _id: "message_id", isRead: true, save: jest.fn() };
    Message.findById = jest.fn().mockResolvedValue(mockedMessage);

    await unreadMessage(req, res);

    expect(User.findById).toHaveBeenCalledWith("user_id");
    expect(Message.findById).toHaveBeenCalledWith("message_id");
    expect(mockedMessage.isRead).toBe(false);
    expect(mockedMessage.save).toHaveBeenCalled();
    expect(res.status).toHaveBeenCalledWith(200);
    expect(res.json).toHaveBeenCalledWith({
      success: true,
      message: "Message unread",
    });
  });

  // Function returns error message with status code 400 when message is not found
  it("should return error message with status code 400 when message is not found", async () => {
    const req = {
      user: {
        userId: "user_id",
      },
      params: {
        id: "message_id",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const User = require("../models/userModel");
    const Message = require("../models/messageModel");
    const unreadMessage =
      require("../controller/message/privateMessageController").unreadMessage;

    User.findById = jest.fn().mockResolvedValue({ _id: "user_id" });
    Message.findById = jest.fn().mockResolvedValue(null);

    await unreadMessage(req, res);

    expect(User.findById).toHaveBeenCalledWith("user_id");
    expect(Message.findById).toHaveBeenCalledWith("message_id");
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.json).toHaveBeenCalledWith({
      success: false,
      message: "Message not found",
    });
  });

  // Function throws an error and returns status code 500 when an error occurs
  it("should throw an error and return status code 500 when an error occurs", async () => {
    const req = {
      user: {
        userId: "user_id",
      },
      params: {
        id: "message_id",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };
    const User = require("../models/userModel");
    const Message = require("../models/messageModel");
    const unreadMessage =
      require("../controller/message/privateMessageController").unreadMessage;

    User.findById = jest.fn().mockResolvedValue({ _id: "user_id" });
    Message.findById = jest
      .fn()
      .mockRejectedValue(new Error("Internal Server Error"));

    await unreadMessage(req, res);

    expect(User.findById).toHaveBeenCalledWith("user_id");
    expect(Message.findById).toHaveBeenCalledWith("message_id");
    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.json).toHaveBeenCalledWith({
      success: false,
      message: "Internal Server Error",
    });
  });
});

// Attempt to delete a message with an invalid message ID
it("should return an error when attempting to delete a message with an invalid message ID", async () => {
  const req = {
    user: {
      userId: "user1",
    },
    params: {
      id: "invalidMessageId",
    },
  };

  const res = {
    status: jest.fn().mockReturnThis(),
    json: jest.fn(),
  };

  const User = require("../models/userModel");
  const Message = require("../models/messageModel");

  User.findById = jest.fn().mockResolvedValue({
    receivedPrivateMessages: [],
    sentPrivateMessages: [],
    save: jest.fn(),
  });

  Message.findById = jest.fn().mockResolvedValue(null);

  await deleteMessage(req, res);

  expect(User.findById).toHaveBeenCalledWith("user1");
  expect(Message.findById).toHaveBeenCalledWith("invalidMessageId");
  expect(res.status).toHaveBeenCalledWith(400);
  expect(res.json).toHaveBeenCalledWith({
    success: false,
    message: "Message not found",
  });
});
